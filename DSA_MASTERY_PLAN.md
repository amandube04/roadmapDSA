# DSA MASTERY PLAN - From Medium Arrays to Interview Ready

## Learning Graph Structure & Dependencies

```
FOUNDATION LAYER
├── Arrays & Strings (STRENGTHEN) → Two Pointers → Sliding Window
├── Hash Maps & Sets → Prefix Sums → Subarray Problems
└── Basic Math & Bit Manipulation → Advanced Bit Tricks

CORE PATTERNS LAYER
├── Recursion & Backtracking → Dynamic Programming
├── Linked Lists → Stacks & Queues → Monotonic Stack/Queue
├── Trees → Binary Search Trees → Advanced Tree Patterns
└── Sorting & Searching → Binary Search → Advanced Search

ADVANCED LAYER
├── Graphs → Topological Sort → Shortest Path → Advanced Graph
├── Dynamic Programming → 2D DP → State Machine DP
├── Greedy Algorithms → Interval Problems → Advanced Greedy
└── Trie & Advanced Data Structures → Segment Tree → Union Find

MASTERY LAYER
├── System Design Algorithms → Distributed Systems Concepts
├── Advanced Graph Algorithms → Network Flow → Minimum Spanning Tree
└── Contest Level Problems → Competitive Programming Techniques
```

---

## PHASE 1: FOUNDATION STRENGTHENING (3-4 weeks)

### 1. Arrays & Strings Enhancement
**Goal**: Master ALL medium-level patterns with 90% retention

**Core Concepts to Master**:
- **Prefix/Suffix Arrays**: Running sums, running products, differences
- **Kadane's Algorithm**: Maximum subarray, variations
- **Dutch National Flag**: 3-way partitioning, color sorting
- **Array Rotation**: In-place rotation, cyclic rotations
- **String Matching**: KMP, Rabin-Karp (basic understanding)

**Problem Count**: 25 problems
**Essential Problems**:
1. Maximum Subarray (LC 53)
2. Product of Array Except Self (LC 238)
3. Rotate Array (LC 189)
4. 3Sum (LC 15)
5. Longest Substring Without Repeating Characters (LC 3)
6. Valid Anagram (LC 242)
7. Group Anagrams (LC 49)
8. Longest Palindromic Substring (LC 5)
9. Container With Most Water (LC 11)
10. Trapping Rain Water (LC 42) - HARD but essential pattern

**Retention Strategy**: 
- Solve each problem 3 times with 2-day gaps
- Create template for each pattern
- Write down the "AHA!" moment for each

### 2. Two Pointers Mastery
**Goal**: Instantly recognize two-pointer scenarios

**Core Concepts**:
- **Opposite Direction**: Start from both ends, move towards center
- **Same Direction**: Fast/slow pointers, sliding window preparation
- **Cycle Detection**: Floyd's algorithm foundation
- **Palindrome Checking**: Efficient string/array palindrome verification

**Problem Count**: 20 problems
**Essential Problems**:
1. Two Sum II (LC 167)
2. Valid Palindrome (LC 125)
3. Remove Duplicates from Sorted Array (LC 26)
4. Merge Sorted Array (LC 88)
5. Linked List Cycle (LC 141) - preparation for linked lists
6. 4Sum (LC 18)
7. Sort Colors (LC 75)
8. Remove Element (LC 27)
9. Reverse String (LC 344)
10. Palindrome Linked List (LC 234)

### 3. Sliding Window Excellence
**Goal**: Handle all sliding window variants confidently

**Core Concepts**:
- **Fixed Size Window**: K-size problems, average calculations
- **Variable Size Window**: Expand/contract based on condition
- **String Window Problems**: Character frequency, anagram detection
- **Optimization Problems**: Maximum/minimum in window

**Problem Count**: 18 problems
**Essential Problems**:
1. Maximum Average Subarray I (LC 643)
2. Longest Substring Without Repeating Characters (LC 3)
3. Minimum Window Substring (LC 76) - HARD but crucial
4. Sliding Window Maximum (LC 239) - HARD
5. Find All Anagrams in a String (LC 438)
6. Permutation in String (LC 567)
7. Longest Repeating Character Replacement (LC 424)
8. Minimum Size Subarray Sum (LC 209)

---

## PHASE 2: CORE DATA STRUCTURES (6-8 weeks)

### 4. Hash Maps & Sets Deep Dive
**Goal**: Use hashing for O(1) lookups in complex scenarios

**Core Concepts**:
- **Frequency Counting**: Character/element frequency problems
- **Complement Finding**: Two sum variants, pair finding
- **Cycle Detection**: Using visited sets
- **Grouping Problems**: Anagrams, isomorphic strings

**Problem Count**: 22 problems
**Essential Problems**:
1. Two Sum (LC 1)
2. Contains Duplicate (LC 217)
3. Intersection of Two Arrays (LC 349)
4. Happy Number (LC 202)
5. Isomorphic Strings (LC 205)
6. Word Pattern (LC 290)
7. Top K Frequent Elements (LC 347)
8. Design HashMap (LC 706)

### 5. Recursion & Backtracking Mastery
**Goal**: Think recursively and handle complex state exploration

**Core Concepts**:
- **Tree Recursion**: Multiple recursive calls, decision trees
- **Backtracking Template**: Choose → Explore → Unchoose
- **Memoization**: Top-down DP preparation
- **State Management**: Tracking visited states, path finding

**Problem Count**: 25 problems
**Essential Problems**:
1. Generate Parentheses (LC 22)
2. Letter Combinations of Phone Number (LC 17)
3. Permutations (LC 46)
4. Subsets (LC 78)
5. Combination Sum (LC 39)
6. Word Search (LC 79)
7. N-Queens (LC 51) - HARD
8. Palindrome Partitioning (LC 131)
9. Restore IP Addresses (LC 93)
10. Sudoku Solver (LC 37) - HARD

### 6. Linked Lists Complete Mastery
**Goal**: Handle all linked list manipulations with confidence

**Core Concepts**:
- **Two Pointer Technique**: Fast/slow, cycle detection
- **Reversal Patterns**: Iterative and recursive reversal
- **Merge Techniques**: Sorted list merging, k-way merge
- **Dummy Node Usage**: Simplifying edge cases

**Problem Count**: 20 problems
**Essential Problems**:
1. Reverse Linked List (LC 206)
2. Merge Two Sorted Lists (LC 21)
3. Remove Nth Node From End (LC 19)
4. Linked List Cycle II (LC 142)
5. Intersection of Two Linked Lists (LC 160)
6. Add Two Numbers (LC 2)
7. Reorder List (LC 143)
8. Merge k Sorted Lists (LC 23) - HARD
9. Copy List with Random Pointer (LC 138)
10. LRU Cache (LC 146) - HARD but crucial

### 7. Trees & Binary Search Trees
**Goal**: Master all tree traversal and manipulation patterns

**Core Concepts**:
- **Traversal Methods**: Inorder, preorder, postorder (recursive & iterative)
- **Tree Properties**: Height, diameter, balance checking
- **BST Operations**: Search, insert, delete, validation
- **Path Problems**: Root-to-leaf, path sum, diameter

**Problem Count**: 30 problems
**Essential Problems**:
1. Binary Tree Inorder Traversal (LC 94)
2. Maximum Depth of Binary Tree (LC 104)
3. Same Tree (LC 100)
4. Symmetric Tree (LC 101)
5. Binary Tree Level Order Traversal (LC 102)
6. Path Sum (LC 112)
7. Construct Binary Tree from Inorder and Preorder (LC 105)
8. Validate Binary Search Tree (LC 98)
9. Lowest Common Ancestor of BST (LC 235)
10. Serialize and Deserialize Binary Tree (LC 297) - HARD

---

## PHASE 3: ADVANCED PATTERNS (8-10 weeks)

### 8. Dynamic Programming Mastery
**Goal**: Recognize DP patterns and solve with confidence

**Core Concepts**:
- **1D DP**: Fibonacci-like, climbing stairs, house robber
- **2D DP**: Grid problems, edit distance, LCS
- **String DP**: Palindrome, subsequence, matching
- **Knapsack Variants**: 0/1, unbounded, multiple constraints

**Problem Count**: 35 problems
**Essential Problems**:
1. Climbing Stairs (LC 70)
2. House Robber (LC 198)
3. Coin Change (LC 322)
4. Longest Increasing Subsequence (LC 300)
5. Edit Distance (LC 72)
6. Longest Common Subsequence (LC 1143)
7. Palindromic Substrings (LC 647)
8. Unique Paths (LC 62)
9. 0/1 Knapsack (Classic)
10. Word Break (LC 139)

### 9. Graphs Complete Mastery
**Goal**: Handle all graph algorithms with confidence

**Core Concepts**:
- **Representation**: Adjacency list, adjacency matrix
- **Traversal**: DFS, BFS, topological sort
- **Shortest Path**: Dijkstra, Floyd-Warshall
- **Connectivity**: Union-Find, strongly connected components

**Problem Count**: 28 problems
**Essential Problems**:
1. Number of Islands (LC 200)
2. Clone Graph (LC 133)
3. Course Schedule (LC 207)
4. Word Ladder (LC 127)
5. Network Delay Time (LC 743)
6. Minimum Spanning Tree (Classic)
7. Detect Cycle in Directed Graph (Classic)
8. Shortest Path in Binary Matrix (LC 1091)

### 10. Advanced Data Structures
**Goal**: Use specialized data structures for optimization

**Core Concepts**:
- **Heap/Priority Queue**: Top K problems, median finding
- **Trie**: Prefix matching, word search
- **Segment Tree**: Range queries, updates
- **Union-Find**: Dynamic connectivity

**Problem Count**: 25 problems
**Essential Problems**:
1. Kth Largest Element (LC 215)
2. Merge k Sorted Lists (LC 23)
3. Find Median from Data Stream (LC 295)
4. Implement Trie (LC 208)
5. Word Search II (LC 212)
6. Range Sum Query (LC 307)
7. Number of Islands II (LC 305)

---

## PHASE 4: MASTERY & INTERVIEW PREP (4-6 weeks)

### 11. System Design Algorithms
**Goal**: Understand scalable algorithm design

**Core Concepts**:
- **Consistent Hashing**: Load balancing, distributed systems
- **Bloom Filters**: Space-efficient membership testing
- **Rate Limiting**: Token bucket, sliding window
- **Caching Strategies**: LRU, LFU, write-through

**Problem Count**: 15 problems
**Essential Problems**:
1. Design LRU Cache (LC 146)
2. Design LFU Cache (LC 460)
3. Design Hit Counter (LC 362)
4. Design Search Autocomplete (LC 642)
5. Design Twitter (LC 355)

### 12. Contest Level Problems
**Goal**: Handle complex, multi-concept problems

**Core Concepts**:
- **Problem Decomposition**: Breaking complex problems
- **Optimization**: Time/space complexity improvements
- **Edge Case Handling**: Comprehensive test case thinking
- **Pattern Recognition**: Quickly identifying solution approaches

**Problem Count**: 20 problems
**Essential Problems**:
1. Regular Expression Matching (LC 10)
2. Wildcard Matching (LC 44)
3. Longest Valid Parentheses (LC 32)
4. Median of Two Sorted Arrays (LC 4)
5. N-Queens II (LC 52)

---

## PROBLEM DIFFICULTY PROGRESSION

### Confidence Building Structure:
- **Easy**: 30% of problems (build confidence)
- **Medium**: 60% of problems (main focus)
- **Hard**: 10% of problems (pattern recognition)

### Total Problem Count by Phase:
- **Phase 1**: 63 problems (Foundation)
- **Phase 2**: 97 problems (Core)
- **Phase 3**: 88 problems (Advanced)
- **Phase 4**: 35 problems (Mastery)
- **Total**: 283 problems

---

## SUCCESS METRICS & CHECKPOINTS

### Weekly Checkpoints:
- **Week 2**: Can solve 80% of previous Array/String problems in 15 minutes
- **Week 4**: Instantly identify Two Pointer opportunities
- **Week 6**: Sliding Window problems feel natural
- **Week 8**: Can implement basic recursion without hesitation
- **Week 12**: Tree problems are solved systematically
- **Week 16**: DP patterns are recognized immediately
- **Week 20**: Graph algorithms are implemented confidently
- **Week 24**: Ready for any interview question

### Final Mastery Test:
- Solve 5 random medium problems in 90 minutes
- Explain approach clearly for each solution
- Handle follow-up questions and optimizations
- Code clean, bug-free solutions on first attempt

---

## RETENTION STRATEGIES

### Daily Practice:
- **New Problem**: 30-45 minutes
- **Review Problem**: 15-20 minutes
- **Pattern Practice**: 10 minutes

### Weekly Review:
- **Saturday**: Solve 3 problems mixing all learned patterns
- **Sunday**: Review weak areas, update pattern templates

### Monthly Assessment:
- **Mock Interview**: Practice with timer
- **Weak Point Analysis**: Focus on struggling areas
- **Pattern Template Update**: Refine based on new learnings

---

## TOOLS & RESOURCES

### Primary Platforms:
- **LeetCode**: Main practice platform
- **NeetCode**: Curated problem lists
- **AlgoExpert**: Structured learning path

### Documentation:
- **Notion/Obsidian**: Pattern templates and notes
- **GitHub**: Solution repository with detailed comments
- **Anki**: Spaced repetition for patterns

### Progress Tracking:
- **Spreadsheet**: Track problems solved, time taken, confidence level
- **Calendar**: Mark daily practice, review sessions
- **GitHub Commits**: Daily coding practice evidence

---

This plan transforms you from "can solve medium arrays but forgets" to "confidently tackles any DSA interview question." Each phase builds upon the previous, ensuring solid retention and progressive skill development.

Remember: **Quality over Quantity** - It's better to deeply understand 283 problems than to superficially solve 1000+.